"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPageContextServerSide = createPageContextServerSide;
exports.createPageContextServerSideWithoutGlobalContext = createPageContextServerSideWithoutGlobalContext;
const utils_js_1 = require("../utils.js");
const getPageContextUrlComputed_js_1 = require("../../../shared/getPageContextUrlComputed.js");
const createPageContextShared_js_1 = require("../../../shared/createPageContextShared.js");
async function createPageContextServerSide(pageContextInit, globalContext, globalObject_public, { isPrerendering, ssr: { urlHandler, isClientSideNavigation } = {
    urlHandler: null,
    isClientSideNavigation: false
} }) {
    (0, utils_js_1.assert)(pageContextInit.urlOriginal);
    const pageContextCreated = createPageContext(pageContextInit, isPrerendering);
    (0, utils_js_1.objectAssign)(pageContextCreated, {
        /* Don't spread globalContext for now? Or never spread it as it leads to confusion? The convenience isn't worth the added confusion?
        // We must use Flatten<T> otherwise TypeScript complains upon assigning types
        ...(globalContext as Flatten<typeof globalContext>), // least precedence
        */
        globalContext: globalObject_public,
        _globalContext: globalContext,
        // The following is defined on `pageContext` because we can eventually make these non-global
        _baseServer: globalContext.baseServer,
        _baseAssets: globalContext.baseAssets,
        // TODO/now: add meta.default
        _includeAssetsImportedByServer: globalContext.config.includeAssetsImportedByServer ?? true,
        // TODO/soon: use GloablContext instead
        _pageFilesAll: globalContext._pageFilesAll,
        _pageConfigs: globalContext._pageConfigs,
        _pageConfigGlobal: globalContext._pageConfigGlobal,
        _allPageIds: globalContext._allPageIds,
        _pageRoutes: globalContext._pageRoutes,
        _onBeforeRouteHook: globalContext._onBeforeRouteHook,
        _pageContextInit: pageContextInit,
        _urlRewrite: null,
        _urlHandler: urlHandler,
        isClientSideNavigation
    });
    // pageContext.urlParsed
    const pageContextUrlComputed = (0, getPageContextUrlComputed_js_1.getPageContextUrlComputed)(pageContextCreated);
    (0, utils_js_1.objectAssign)(pageContextCreated, pageContextUrlComputed);
    // pageContext.headers
    {
        let headers;
        if (pageContextInit.headersOriginal) {
            headers = (0, utils_js_1.normalizeHeaders)(pageContextInit.headersOriginal);
            (0, utils_js_1.assertUsage)(!('headers' in pageContextInit), "You're defining pageContextInit.headersOriginal as well as pageContextInit.headers but you should only define pageContextInit.headersOriginal instead, see https://vike.dev/headers");
        }
        else if (pageContextInit.headers) {
            headers = pageContextInit.headers;
            // TODO/next-major-release: remove
            (0, utils_js_1.assertWarning)(false, 'Setting pageContextInit.headers is deprecated: set pageContextInit.headersOriginal instead, see https://vike.dev/headers', { onlyOnce: true });
        }
        else {
            headers = null;
        }
        (0, utils_js_1.objectAssign)(pageContextCreated, { headers });
    }
    const pageContextAugmented = await (0, createPageContextShared_js_1.createPageContextShared)(pageContextCreated, globalContext._pageConfigGlobal);
    (0, utils_js_1.augmentType)(pageContextCreated, pageContextAugmented);
    return pageContextCreated;
}
function createPageContextServerSideWithoutGlobalContext(pageContextInit) {
    const pageContext = createPageContext(pageContextInit, false);
    return pageContext;
}
function createPageContext(pageContextInit, isPrerendering) {
    const pageContext = {
        isClientSide: false,
        isPrerendering
    };
    (0, utils_js_1.objectAssign)(pageContext, pageContextInit);
    return pageContext;
}
