"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginAutoFullBuild = pluginAutoFullBuild;
exports.isPrerenderForceExit = isPrerenderForceExit;
const vite_1 = require("vite");
const utils_js_1 = require("../../utils.js");
const runPrerender_js_1 = require("../../../prerender/runPrerender.js");
const context_js_1 = require("../../../prerender/context.js");
const isViteCliCall_js_1 = require("../../shared/isViteCliCall.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const logErrorHint_js_1 = require("../../../runtime/renderPage/logErrorHint.js");
const pluginBuildConfig_js_1 = require("./pluginBuildConfig.js");
const getVikeConfig_js_1 = require("../importUserCode/v1-design/getVikeConfig.js");
const context_js_2 = require("../../../api/context.js");
const handleAssetsManifest_js_1 = require("./handleAssetsManifest.js");
const isViteServerBuild_js_1 = require("../../shared/isViteServerBuild.js");
(0, utils_js_1.assertIsSingleModuleInstance)('build/pluginAutoFullBuild.ts');
let forceExit = false;
function pluginAutoFullBuild() {
    let config;
    let vikeConfig;
    return [
        {
            name: 'vike:build:pluginAutoFullBuild',
            apply: 'build',
            enforce: 'pre',
            async configResolved(config_) {
                vikeConfig = await (0, getVikeConfig_js_1.getVikeConfig)(config_);
                config = config_;
                abortViteBuildSsr(vikeConfig);
            },
            writeBundle: {
                /* We can't use this because it breaks Vite's logging. TODO/eventually: try again with latest Vite version.
                sequential: true,
                order: 'pre',
                */
                async handler(options, bundle) {
                    await (0, handleAssetsManifest_js_1.handleAssetsManifest)(config, this.environment, options, bundle);
                    await triggerFullBuild(config, vikeConfig, this.environment, bundle);
                }
            }
        },
        {
            name: 'vike:build:pluginAutoFullBuild:forceExit',
            apply: 'build',
            enforce: 'post',
            closeBundle: {
                sequential: true,
                order: 'post',
                handler() {
                    (0, utils_js_1.onSetupBuild)();
                    (0, handleAssetsManifest_js_1.handleAssetsManifest_assertUsageCssTarget)(config);
                    if (forceExit &&
                        // Let vike:build:pluginBuildApp force exit
                        !vikeConfig.global.config.vite6BuilderApp) {
                        (0, runPrerender_js_1.runPrerender_forceExit)();
                        (0, utils_js_1.assert)(false);
                    }
                }
            }
        }
    ];
}
async function triggerFullBuild(config, vikeConfig, viteEnv, bundle) {
    // Whether builder.buildApp() is being used, see plugin:build:pluginBuildApp
    const isBuilderApp = vikeConfig.global.config.vite6BuilderApp;
    // If builder.buildApp() => trigger at end of `this.environment.name === 'ssr'`.
    // Else => trigger at end of client-side build.
    if (isBuilderApp ? !(0, isViteServerBuild_js_1.isViteServerBuild_onlySsrEnv)(config, viteEnv) : !(0, isViteServerBuild_js_1.isViteClientBuild)(config, viteEnv))
        return;
    if (isEntirelyDisabled(vikeConfig))
        return;
    // Workaround for @vitejs/plugin-legacy
    //  - The legacy plugin triggers its own Rollup build for the client-side.
    //  - The legacy plugin doesn't generate a manifest => we can use that to detect the legacy plugin build.
    //  - Issue & reproduction: https://github.com/vikejs/vike/issues/1154#issuecomment-1965954636
    if (!bundle[pluginBuildConfig_js_1.manifestTempFile])
        return;
    const configInline = getFullBuildInlineConfig(config);
    if (!isBuilderApp) {
        try {
            await (0, vite_1.build)(setSSR(configInline));
        }
        catch (err) {
            // Avoid Rollup prefixing the error with [vike:build:pluginAutoFullBuild], see for example https://github.com/vikejs/vike/issues/472#issuecomment-1276274203
            console.error(err);
            (0, logErrorHint_js_1.logErrorHint)(err);
            process.exit(1);
        }
    }
    else {
        // The server bulid is already called by builder.buildApp()
    }
    if ((0, context_js_1.isPrerenderAutoRunEnabled)(vikeConfig)) {
        const res = await (0, runPrerender_js_1.runPrerenderFromAutoRun)(configInline);
        forceExit = res.forceExit;
    }
}
function setSSR(configInline) {
    return {
        ...configInline,
        build: {
            ...configInline.build,
            ssr: true
        }
    };
}
function abortViteBuildSsr(vikeConfig) {
    if (vikeConfig.global.config.disableAutoFullBuild !== true && (0, isViteCliCall_js_1.isViteCliCall)() && (0, isViteCliCall_js_1.getViteConfigFromCli)()?.build.ssr) {
        (0, utils_js_1.assertWarning)(false, `The CLI call ${picocolors_1.default.cyan('$ vite build --ssr')} is superfluous since ${picocolors_1.default.cyan('$ vite build')} also builds the server-side. If you want two separate build steps then use https://vike.dev/disableAutoFullBuild or use Vite's ${picocolors_1.default.cyan('build()')} API.`, { onlyOnce: true });
        process.exit(0);
    }
}
function isEntirelyDisabled(vikeConfig) {
    const { disableAutoFullBuild } = vikeConfig.global.config;
    if (disableAutoFullBuild === undefined || disableAutoFullBuild === 'prerender') {
        const isUserUsingViteApi = !(0, isViteCliCall_js_1.isViteCliCall)() && !(0, context_js_2.isVikeCliOrApi)();
        return isUserUsingViteApi;
    }
    else {
        return disableAutoFullBuild;
    }
}
function isPrerenderForceExit() {
    return forceExit;
}
function getFullBuildInlineConfig(config) {
    const configFromCli = !(0, isViteCliCall_js_1.isViteCliCall)() ? null : (0, isViteCliCall_js_1.getViteConfigFromCli)();
    if (config._viteConfigFromUserEnhanced) {
        return config._viteConfigFromUserEnhanced;
    }
    else {
        return {
            ...configFromCli,
            configFile: configFromCli?.configFile || config.configFile,
            root: config.root,
            build: {
                ...configFromCli?.build
            }
        };
    }
}
